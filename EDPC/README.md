# Educational DP Contest
## A 1次元DP
- 普通の1次元DP

## B 1次元DP
- 普通の1次元DP．Aにループがついた
- DPはインデックス管理が面倒なので1-indexedで実装しようと思う．

## C 2次元DP
- 2次元DP．サイズは$`N \times 3`$
- N日目にA, B, Cいずれかの行動をする時の最大の幸福度

## D ナップザック問題
- ```dp[i+1][j+w[i]]```とするより，```dp[i+1][j-w[i]]```で管理した方が良さそう

## E ナップザック問題
- D問題と問題文は同じで，制約だけが変わった．
- DPテーブルを品物の数と重さで作ると，計算量が$`O(NW)`$となり，今回は$`W <= 10^9`$なので，TLEとなる
- 制約に着目し，DPテーブルを品物と，価値の合計値でとると可能になる．

## F　LCS(最長共通部分列問題)
- LCS = Longest-common subsequence problem
- DPテーブルで文字列を扱ってしまうと，毎回文字列のコピーが必要になるため，計算量が$`O(|s|^2|t|)`$になってしまい，TLEになってしまう．
- 回避するためには，共通部分列の長さを持つDPテーブルを作成し，最後にDPテーブルをもとに文字列を復元すれば良い．

## G DAG(有向閉路のないグラフ)上のDP
- DAG = Directed Acyclic Graph
### 自分の解法
- メモ化再帰を使用
- メモ化再帰はDPの更新順序が非自明である時に有効

### 別解
- トポロジカルソートをして，ノードの更新順を決定後DPを走査

## H 数え上げ問題
- 簡単な2次元DP
- 貰うDPで実装．（配るDPでも出来る）
- 適宜$`10^9+7`$で割るのを忘れずに

## I 確率DP
- 結局普通の2次元DP

## J 期待値DP
- 試行回数が無限回になるので考え方を工夫する必要がある．
- DPの状態遷移を考えてそれを圧縮する．
- 自己ループは式変形によって無くす．
- DPテーブルの作り方も工夫がいるが，`dp[i][j][k] := 寿司が残り1個の皿がi枚、個の皿がj枚、3個の皿がk枚の状態から、寿司をすべてなくすのに必要な操作回数の期待値`と置くことでうまく遷移できる．
- (参考)[https://qiita.com/drken/items/03c7db44ccd27820ea0d#j-%E5%95%8F%E9%A1%8C---sushi]
- 慣れないと結構難しいと感じた．